<docs-item>
    <docs-fragment fragment="what-is-ngqp">
        <h2>What is ngqp?</h2>
    </docs-fragment>
    <p>
        ngqp gives you a declarative approach to synchronizing the state of UI components (such as inputs or selects)
        to the URL as query parameters (e.g., <code class="nobreak">?q=Hello+World</code>). In doing so you can improve
        user experience in your application by retaining state when users…
    </p>
    <ul class="checkmark-list">
        <li>refresh the page either actively or accidentally (think mobile browsers)</li>
        <li>navigate in your app and use the back button</li>
        <li>want to bookmark or share a specific state of the application</li>
    </ul>
    <p>
        Implementing this from scratch not only requires a lot of boilerplate code, but also requires careful
        orchestration between the URL, the components bound to these parameters and the actual work you want to do
        based on them (network requests, applying filters, paginating, …)
    </p>
    <p>
        Using ngqp's declarative approach you can focus on the <em>what</em> rather than the <em>how</em>. It is heavily
        inspired by the Reactive Forms API (<code>@angular/forms</code>), mirroring its APIs in order to make using it
        intuitive and easy.
    </p>
    <p>
        Learn how ngqp works and how to use it by going to the <docs-link [page]="DocsPage.USAGE_GUIDE">next section</docs-link>.
    </p>

    <docs-fragment fragment="limitations">
        <h2>Limitations</h2>
    </docs-fragment>
    <p>
        Since ngqp needs to have full control over the bound components you cannot use Angular forms or reactive forms
        on the same components, i.e., use <code>ngModel</code>, <code>formControl</code> or <code>formControlName</code>
        on them.
    </p>
</docs-item>